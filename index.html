<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>DSSSB Cipher (v2 - Image Support)</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            line-height: 1.6;
            color: #333;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
        }
        .container {
            max-width: 1600px;
            margin: 0 auto;
            padding: 20px;
        }
        .header {
            background: rgba(255, 255, 255, 0.95);
            backdrop-filter: blur(10px);
            padding: 30px;
            border-radius: 20px;
            margin-bottom: 30px;
            box-shadow: 0 20px 40px rgba(0, 0, 0, 0.1);
            text-align: center;
        }
        .header h1 {
            color: #2c3e50;
            font-size: 2.5rem;
            margin-bottom: 10px;
            font-weight: 700;
        }
        .header p {
            color: #7f8c8d;
            font-size: 1.1rem;
        }
        .stats-container {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(220px, 1fr));
            gap: 20px;
            margin-bottom: 30px;
        }
        .stat-card {
            background: rgba(255, 255, 255, 0.9);
            backdrop-filter: blur(10px);
            padding: 25px;
            border-radius: 15px;
            text-align: center;
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.1);
            transition: transform 0.3s ease, box-shadow 0.3s ease;
        }
        .stat-card:hover {
            transform: translateY(-5px);
            box-shadow: 0 20px 40px rgba(0, 0, 0, 0.15);
        }
        .stat-value {
            font-size: 2rem;
            font-weight: bold;
            color: #3498db;
            margin-bottom: 5px;
        }
        .stat-label {
            color: #7f8c8d;
            font-size: 0.9rem;
        }
        .form-container {
            background: rgba(255, 255, 255, 0.95);
            backdrop-filter: blur(10px);
            padding: 30px;
            border-radius: 20px;
            margin-bottom: 30px;
            box-shadow: 0 20px 40px rgba(0, 0, 0, 0.1);
            scroll-margin-top: 20px; /* For smooth scrolling */
        }
        .form-title {
            color: #2c3e50;
            font-size: 1.8rem;
            margin-bottom: 20px;
            font-weight: 600;
        }
        .form-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(220px, 1fr));
            gap: 20px;
            margin-bottom: 20px;
        }
        .form-group {
            display: flex;
            flex-direction: column;
        }
        .form-group.full-width {
            grid-column: 1 / -1;
        }
        .form-group.half-width {
            grid-template-columns: 1fr 1fr;
            gap: 15px;
            display: grid;
        }
        .form-group label {
            margin-bottom: 8px;
            font-weight: 600;
            color: #2c3e50;
            font-size: 0.9rem;
        }
        .form-group input, .form-group select, .form-group textarea {
            padding: 12px 15px;
            border: 2px solid #e0e6ed;
            border-radius: 10px;
            font-size: 1rem;
            transition: border-color 0.3s ease, box-shadow 0.3s ease;
            background-color: #fff;
            width: 100%;
        }
        .form-group textarea {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            resize: vertical;
            min-height: 60px;
        }
        .form-group input:focus, .form-group select:focus, .form-group textarea:focus {
            outline: none;
            border-color: #3498db;
            box-shadow: 0 0 0 3px rgba(52, 152, 219, 0.1);
        }
        .btn {
            background: linear-gradient(135deg, #3498db, #2980b9);
            color: white;
            padding: 15px 30px;
            border: none;
            border-radius: 10px;
            font-size: 1rem;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s ease;
            box-shadow: 0 5px 15px rgba(52, 152, 219, 0.3);
        }
        .btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 8px 25px rgba(52, 152, 219, 0.4);
        }
        .btn:disabled {
            background: #bdc3c7;
            cursor: not-allowed;
            box-shadow: none;
            transform: none;
        }
        .btn-danger {
            background: linear-gradient(135deg, #e74c3c, #c0392b);
            box-shadow: 0 5px 15px rgba(231, 76, 60, 0.3);
            margin-left: 10px;
        }
        .btn-danger:hover {
             box-shadow: 0 8px 25px rgba(231, 76, 60, 0.4);
        }
        .btn-secondary {
            background: linear-gradient(135deg, #27ae60, #229954);
            box-shadow: 0 5px 15px rgba(39, 174, 96, 0.3);
            margin-left: 10px;
        }
        .btn-secondary:hover {
            box-shadow: 0 8px 25px rgba(39, 174, 96, 0.4);
        }
        .btn-tertiary {
            background: linear-gradient(135deg, #f39c12, #e67e22);
            box-shadow: 0 5px 15px rgba(243, 156, 18, 0.3);
            margin-left: 10px;
        }
        .btn-tertiary:hover {
            box-shadow: 0 8px 25px rgba(243, 156, 18, 0.4);
        }
        .btn-info {
            background: linear-gradient(135deg, #9b59b6, #8e44ad);
            box-shadow: 0 5px 15px rgba(155, 89, 182, 0.3);
            margin-left: 10px;
        }
        .btn-info:hover {
            box-shadow: 0 8px 25px rgba(155, 89, 182, 0.4);
        }
        /* Style for table action buttons */
        .action-btn {
            padding: 5px 10px;
            font-size: 0.9rem;
            margin: 2px;
        }
        .table-container {
            background: rgba(255, 255, 255, 0.95);
            backdrop-filter: blur(10px);
            border-radius: 20px;
            overflow: hidden;
            box-shadow: 0 20px 40px rgba(0, 0, 0, 0.1);
            margin-bottom: 30px;
        }
        .table-header {
            background: linear-gradient(135deg, #2c3e50, #34495e);
            color: white;
            padding: 20px 30px;
            display: flex;
            justify-content: space-between;
            align-items: center;
            flex-wrap: wrap;
        }
        .table-header h2 {
            font-size: 1.5rem;
            font-weight: 600;
        }
        .table-wrapper {
            overflow-x: auto;
            max-height: 600px;
            overflow-y: auto;
        }
        table {
            width: 100%;
            border-collapse: collapse;
        }
        th, td {
            padding: 15px;
            text-align: left;
            border-bottom: 1px solid #e8f4f8;
            white-space: nowrap;
        }
        td:last-child {
            white-space: normal; /* Allow action buttons to wrap */
        }
        th {
            background: #f8f9fa;
            font-weight: 600;
            color: #2c3e50;
            position: sticky;
            top: 0;
            z-index: 10;
        }
        tr:hover {
            background: rgba(52, 152, 219, 0.05);
        }
        .delete-btn {
            background: #e74c3c;
            color: white;
            border: none;
            padding: 8px 12px;
            border-radius: 5px;
            cursor: pointer;
            font-size: 0.8rem;
            transition: background 0.3s ease;
            margin: 2px;
        }
        .delete-btn:hover {
            background: #c0392b;
        }
        .filter-container {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 15px;
            margin-bottom: 20px;
            padding: 20px;
        }
        .filter-container select, .filter-container input, .filter-container button {
            padding: 10px;
            border: 2px solid #e0e6ed;
            border-radius: 8px;
            width: 100%;
            background-color: #fff;
        }
        .filter-container button {
            grid-column: 1 / -1;
            padding: 12px 15px;
        }
        .review-panel {
            position: fixed;
            bottom: 0;
            left: 0;
            right: 0;
            background: rgba(255, 255, 255, 0.98);
            backdrop-filter: blur(15px);
            border-top: 2px solid #e0e6ed;
            padding: 20px;
            box-shadow: 0 -10px 40px rgba(0,0,0,0.15);
            transform: translateY(100%);
            transition: transform 0.4s ease-in-out;
            z-index: 1000;
            max-height: 90vh;
            overflow-y: auto;
        }
        .review-panel.visible {
            transform: translateY(0);
        }
        .flashcard {
            background: #f8f9fa;
            border: 1px solid #e0e6ed;
            border-radius: 15px;
            padding: 25px;
            min-height: 200px;
            display: flex;
            flex-direction: column;
            justify-content: center;
            text-align: left;
            font-size: 1.2rem;
            margin-bottom: 20px;
            white-space: pre-wrap;
        }
        .flashcard img {
            max-width: 100%;
            height: auto;
            border-radius: 10px;
            margin-top: 10px;
            border: 1px solid #ddd;
        }
        .flashcard-question-text {
            font-weight: 600;
            margin-bottom: 15px;
        }
        .flashcard-options {
            list-style: none;
            padding-left: 0;
        }
        .flashcard-options li {
            margin-bottom: 8px;
            display: flex;
            flex-direction: column;
        }
        .flashcard-options img {
            max-width: 100%; /* Changed from 300px */
            height: auto;
            border-radius: 8px;
        }
        .flashcard-answer {
            border-top: 1px dashed #bdc3c7;
            margin-top: 15px;
            padding-top: 15px;
            color: #27ae60;
            font-weight: 600;
        }
        .flashcard-answer img {
             max-width: 100%; /* Changed from 300px */
             height: auto;
             border-radius: 8px;
        }
        .review-controls {
            display: flex;
            justify-content: center;
            gap: 15px;
            flex-wrap: wrap;
        }
        .progress-bar-container {
            margin-bottom: 15px;
        }
        .progress-bar {
            height: 10px;
            background: #e0e6ed;
            border-radius: 5px;
            overflow: hidden;
        }
        .progress-bar-fill {
            height: 100%;
            background: linear-gradient(135deg, #3498db, #2980b9);
            transition: width 0.3s ease;
        }
        .modal-overlay {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0,0,0,0.6);
            backdrop-filter: blur(5px);
            display: none;
            align-items: center;
            justify-content: center;
            z-index: 2000;
        }
        .modal-box {
            background: white;
            padding: 30px;
            border-radius: 20px;
            max-width: 800px;
            width: 90%;
            max-height: 80vh;
            overflow-y: auto;
            box-shadow: 0 20px 40px rgba(0,0,0,0.2);
        }
        .modal-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            border-bottom: 1px solid #e0e6ed;
            padding-bottom: 15px;
            margin-bottom: 20px;
        }
        .modal-title {
            font-size: 1.5rem;
            font-weight: 600;
            color: #2c3e50;
        }
        .modal-close-btn {
            font-size: 2rem;
            font-weight: bold;
            color: #7f8c8d;
            cursor: pointer;
            border: none;
            background: none;
        }
        .modal-body {
            line-height: 1.8;
            /* white-space: pre-wrap; */ /* Removed as renderContent handles it */
        }
        .modal-body img {
            max-width: 100%;
            height: auto;
            border-radius: 10px;
            margin-top: 10px;
            border: 1px solid #ddd;
        }
        .modal-option {
            padding: 10px;
            border-radius: 8px;
            border: 1px solid #e0e6ed;
            margin-bottom: 10px;
        }
        .modal-option.correct {
            border-color: #27ae60;
            background-color: #f0fdf4;
            box-shadow: 0 0 10px rgba(39, 174, 96, 0.1);
        }
        .modal-option.correct-label {
             font-weight: bold;
             color: #27ae60;
        }
        @media (max-width: 768px) {
            .container { padding: 10px; }
            .header h1 { font-size: 1.8rem; }
            .form-grid, .form-group.half-width { grid-template-columns: 1fr; }
            .table-header {
                flex-direction: column;
                gap: 15px;
                align-items: flex-start;
            }
            .table-header div {
                display: flex;
                flex-direction: column;
                gap: 10px;
                width: 100%;
            }
            .table-header .btn {
                margin-left: 0;
                width: 100%;
            }
            
            /* Mobile modal and review panel button adjustments */
            .review-controls .btn, .modal-footer .btn {
                padding: 12px 20px;
                font-size: 0.9rem;
            }
            .modal-box {
                padding: 20px;
            }
            .modal-title {
                font-size: 1.2rem;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1>DSSSB Cipher</h1>
            <p>Log and analyze each question (text and images) to identify strengths and weaknesses.</p>
        </div>

        <div class="stats-container">
            <div class="stat-card">
                <div class="stat-value" id="totalQuestions">0</div>
                <div class="stat-label">Total Questions Logged</div>
            </div>
            <div class="stat-card">
                <div class="stat-value" id="sectionAQuestions">0</div>
                <div class="stat-label">Section A Questions</div>
            </div>
            <div class="stat-card">
                <div class="stat-value" id="sectionBQuestions">0</div>
                <div class="stat-label">Section B Questions</div>
            </div>
             <div class="stat-card">
                <div class="stat-value" id="filteredQuestions">0</div>
                <div class="stat-label">Filtered Questions</div>
            </div>
        </div>

        <div class="form-container">
            <h2 class="form-title" id="formTitle">Add Single Question</h2>
            <div class="form-grid">
                 <div class="form-group">
                    <label for="paperNumber">Paper Number</label>
                    <input type="number" id="paperNumber" min="1" max="12" required>
                </div>
                <div class="form-group">
                    <label for="questionNumber">Question Number</label>
                    <input type="number" id="questionNumber" min="1" max="200" required>
                </div>
                <div class="form-group">
                    <label for="section">Section</label>
                    <select id="section" required>
                        <option value="">Select Section</option>
                        <option value="Section A">Section A (General)</option>
                        <option value="Section B">Section B (Subject Specific)</option>
                    </select>
                </div>
                <div class="form-group">
                    <label for="subject">Subject</label>
                    <select id="subject" required disabled>
                        <option value="">Select Subject</option>
                    </select>
                </div>
                <div class="form-group">
                    <label for="topic">Topic</label>
                    <select id="topic" required disabled>
                        <option value="">Select Topic</option>
                    </select>
                </div>
                <div class="form-group">
                    <label for="subtopic">Subtopic</label>
                    <select id="subtopic" required disabled>
                        <option value="">Select Subtopic</option>
                    </select>
                </div>
                 <div class="form-group full-width">
                    <label for="questionText">Question Text (Optional)</label>
                    <textarea id="questionText" rows="3" placeholder="Enter the full question text here..."></textarea>
                </div>
                <div class="form-group full-width">
                    <label for="questionImage">Question Image Base64 (Optional)</label>
                    <textarea id="questionImage" rows="3" placeholder="Paste Base64 for question image (e.g., data:image/png;base64,iVBO...)..."></textarea>
                </div>

                <!-- Option A -->
                <div class="form-group half-width full-width">
                    <div>
                        <label for="optionA">Option A Text (Optional)</label>
                        <input type="text" id="optionA" placeholder="Text for option A">
                    </div>
                    <div>
                        <label for="optionAImage">Option A Image Base64 (Optional)</label>
                        <textarea id="optionAImage" rows="2" placeholder="Paste Base64 for option A..."></textarea>
                    </div>
                </div>
                <!-- Option B -->
                <div class="form-group half-width full-width">
                    <div>
                        <label for="optionB">Option B Text (Optional)</label>
                        <input type="text" id="optionB" placeholder="Text for option B">
                    </div>
                    <div>
                        <label for="optionBImage">Option B Image Base64 (Optional)</label>
                        <textarea id="optionBImage" rows="2" placeholder="Paste Base64 for option B..."></textarea>
                    </div>
                </div>
                <!-- Option C -->
                <div class="form-group half-width full-width">
                    <div>
                        <label for="optionC">Option C Text (Optional)</label>
                        <input type="text" id="optionC" placeholder="Text for option C">
                    </div>
                    <div>
                        <label for="optionCImage">Option C Image Base64 (Optional)</label>
                        <textarea id="optionCImage" rows="2" placeholder="Paste Base64 for option C..."></textarea>
                    </div>
                </div>
                <!-- Option D -->
                <div class="form-group half-width full-width">
                    <div>
                        <label for="optionD">Option D Text (Optional)</label>
                        <input type="text" id="optionD" placeholder="Text for option D">
                    </div>
                    <div>
                        <label for="optionDImage">Option D Image Base64 (Optional)</label>
                        <textarea id="optionDImage" rows="2" placeholder="Paste Base64 for option D..."></textarea>
                    </div>
                </div>
                
                 <div class="form-group">
                    <label for="correctOption">Correct Option</label>
                    <select id="correctOption" required>
                        <option value="">Select Correct Option</option>
                        <option value="A">A</option>
                        <option value="B">B</option>
                        <option value="C">C</option>
                        <option value="D">D</option>
                    </select>
                </div>
                <div class="form-group full-width">
                    <label for="correctAnswerText">Correct Answer Explanation (Optional)</label>
                    <textarea id="correctAnswerText" rows="2" placeholder="Enter an explanation or the text of the correct answer..."></textarea>
                </div>
            </div>
            <!-- Modified Button Section -->
            <button class="btn" id="addQuestionBtn" onclick="addQuestion()">Add Question</button>
            <button class="btn btn-secondary" id="cancelEditBtn" onclick="cancelEdit()" style="display: none; margin-left: 10px;">Cancel Edit</button>
        </div>
        
        <div class="form-container">
            <h2 class="form-title">Batch Import Questions</h2>
            <div class="form-group">
                <label for="batchData">Paste Gem Output Here (from converter.html)</label>
                <textarea id="batchData" rows="10" placeholder="Paste the JSON array from the Gem or Converter tool here..."></textarea>
            </div>
            <button class="btn" onclick="batchImport()">Import Batch</button>
        </div>

        <div class="table-container">
            <div class="table-header">
                <h2>Question Log</h2>
                 <div>
                    <button class="btn btn-danger" onclick="deleteSelected()">Delete Selected</button>
                    <button class="btn btn-danger" onclick="deleteAll()">Delete All</button>
                    <button class="btn btn-info" onclick="copyMetadata()">Copy Metadata</button>
                    <input type="file" id="csvFileInput" style="display: none;" accept=".csv">
                    <button class="btn btn-tertiary" onclick="document.getElementById('csvFileInput').click()">Import CSV</button>
                    <button class="btn btn-secondary" onclick="exportData()">Export All to CSV</button>
                    <button class="btn btn-secondary" onclick="exportFilteredData()">Export Filtered to CSV</button>
                </div>
            </div>
            <div class="filter-container">
                <select id="filterPaper" onchange="filterData()">
                    <option value="">All Papers</option>
                </select>
                <!-- 
                REMOVED per request 1
                <select id="filterSection" onchange="updateFilterSubjectOptions()">
                    <option value="">All Sections</option>
                    <option value="Section A">Section A</option>
                    <option value="Section B">Section B</option>
                </select> 
                -->
                <select id="filterSubject" onchange="updateFilterTopicOptions()" disabled>
                    <option value="">All Subjects</option>
                </select>
                <select id="filterTopic" onchange="updateFilterSubtopicOptions()" disabled>
                    <option value="">All Topics</option>
                </select>
                <select id="filterSubtopic" onchange="filterData()" disabled>
                    <option value="">All Subtopics</option>
                </select>
                 <!-- MODIFIED per request 4 -->
                 <input type="text" id="searchKeyword" placeholder="Search by Keyword or Q#" onkeyup="filterData()">
                 <button class="btn" onclick="startReview()">Start Review of Filtered Questions</button>
            </div>
            <div class="table-wrapper">
                <table id="dataTable">
                    <thead>
                        <tr>
                            <th><input type="checkbox" onchange="toggleSelectAll(this.checked)"></th>
                            <th>Paper#</th>
                            <th>Q#</th>
                            <th>Section</th>
                            <th>Subject</th>
                            <th>Topic</th>
                            <th>Subtopic</th>
                            <th>Actions</th>
                            <th>Delete</th>
                        </tr>
                    </thead>
                    <tbody id="tableBody">
                    </tbody>
                </table>
            </div>
        </div>
    </div>
    
    <div class="review-panel" id="reviewPanel">
        <div class="progress-bar-container">
            <div class="progress-bar">
                <div class="progress-bar-fill" id="reviewProgressBar"></div>
            </div>
        </div>
        <div class="flashcard" id="flashcard">
            <!-- Content dynamically inserted by loadNextCard() -->
            <div id="flashcardContent">
                <!-- Metadata will be inserted here -->
                <div class="flashcard-question-text"></div>
                <ul class="flashcard-options">
                    <li></li>
                    <li></li>
                    <li></li>
                    <li></li>
                </ul>
            </div>
            <div id="flashcardAnswer" class="flashcard-answer" style="display: none;"></div>
        </div>
        <!-- MODIFIED per request 3 -->
        <div class="review-controls" id="reviewControls">
            <button class="btn" id="showAnswerBtn" onclick="showAnswer()">Show Answer</button>
            <!-- New Nav Controls -->
            <div id="navControls" style="display: none; width: 100%; justify-content: space-between; align-items: center; gap: 15px;">
                 <button class="btn btn-tertiary" onclick="navigateReview(-1)" id="reviewPrevBtn">&larr; Previous</button>
                 <span id="reviewCounter" style="font-size: 0.9rem; color: #555; white-space: nowrap;"></span>
                 <button class="btn" onclick="navigateReview(1)" id="reviewNextBtn">Next &rarr;</button>
            </div>
            <!-- Old Rating Controls (kept in HTML but hidden) -->
            <div id="ratingControls" style="display: none;">
                 <button class="btn btn-danger" onclick="rateCard('Again')">Again</button>
                 <button class="btn btn-tertiary" onclick="rateCard('Hard')">Hard</button>
                 <button class="btn" onclick="rateCard('Good')">Good</button>
                 <button class="btn btn-secondary" onclick="rateCard('Easy')">Easy</button>
            </div>
        </div>
         <button class="btn" style="position: absolute; top: 20px; right: 20px;" onclick="closeReview()">Close</button>
    </div>

    <div class="modal-overlay" id="detailsModal">
        <div class="modal-box">
            <div class="modal-header">
                <h2 class="modal-title" id="modalTitle">Question Details</h2>
                <button class="modal-close-btn" onclick="closeDetailsModal()">&times;</button>
            </div>
            <!-- Content (including footer) dynamically inserted by renderModalContent() -->
            <div class="modal-body" id="modalBody">
            </div>
        </div>
    </div>

    <script>
    // In-memory representation of the DSSSB syllabus structure.
    const syllabusStructure = {
        "Section A": {
            "General Awareness": {
                "History": ["N/A"], "Polity": ["N/A"], "Constitution": ["N/A"], "Sports": ["N/A"], "Art & Culture": ["N/A"], "Geography": ["N/A"], "Economics": ["N/A"], "Everyday Science": ["N/A"], "Scientific Research": ["N/A"], "National/ International Organizations/ Institutions": ["N/A"], "Current Events": ["N/A"]
            },
            "General Intelligence & Reasoning Ability": {
                "Analogy": ["N/A"], "Classification": ["N/A"], "Series": ["N/A"], "Coding-Decoding": ["N/A"], "Blood Relations": ["N/A"], "Direction Sense Test": ["N/A"], "Logical Venn Diagrams": ["N/A"], "Alphabet Test": ["N/A"], "Sitting Arrangements": ["N/A"], "Mathematical Operations": ["N/A"], "Arithmetical Reasoning": ["N/A"], "Inserting the missing character": ["N/A"], "Number, Ranking and Time Sequence Test": ["N/A"], "Eligibility Test": ["N/A"], "Syllogism": ["N/A"], "Statement and Arguments": ["N/A"], "Statement and Assumptions": ["N/A"], "Statement and Courses of action": ["N/A"], "Statement and Conclusions": ["N/A"], "Deriving Conclusion": ["N/A"], "Assertion and Reason": ["N/A"], "Punch Lines": ["N/A"], "Situation Reaction Tests": ["N/A"], "Cause and Effect": ["N/A"], "Analytical Reasoning": ["N/A"]
            },
            "Arithmetical & Numerical Ability": {
                "Number Systems": ["Simplification", "Decimals", "Fractions", "L.C.M.", "H.C.F."], "Data Interpretation": ["Tables & Graphs", "Pie Chart", "Line Chart", "Line Graph", "Bar Graph", "Venn Diagrams"], "Ratio & Proportion": ["N/A"], "Percentage": ["N/A"], "Average": ["N/A"], "Profit & Loss": ["N/A"], "Discount": ["N/A"], "Simple & Compound Interest": ["N/A"], "Mensuration": ["N/A"], "Time & Work": ["N/A"], "Time & Distance": ["N/A"]
            },
            "English Language & Comprehension": {
                "Parts of speech": ["N/A"], "Tenses": ["N/A"], "Articles & Determiners": ["N/A"], "Subject-Verb Agreement": ["N/A"], "Voice": ["N/A"], "Narration (Direct & Indirect Speech)": ["N/A"], "Sentence Structure": ["N/A"], "Error Detection & Correction": ["N/A"], "Transformation of Sentences": ["N/A"], "Punctuation & Capitalization": ["N/A"], "Modifiers": ["N/A"], "Antonyms": ["N/A"], "Synonyms": ["N/A"], "One-word substitutions": ["N/A"], "Idioms & Phrases": ["N/A"], "Homonyms, Homophones": ["N/A"], "Spelling rules & common errors": ["N/A"], "Word formation (prefix, suffix, root words)": ["N/A"], "Unseen passage": ["N/A"]
            },
            "Hindi Language & Comprehension": {
                "स्वर और व्यंजन": ["N/A"], "संधि (स्वर संधि, व्यंजन संधि, विसर्ग संधि)": ["N/A"], "संधि विच्छेद": ["N/A"], "तत्सम, तद्भव, देशज, विदेशी शब्द": ["N/A"], "पर्यायवाची (Synonyms)": ["N/A"], "विलोम (Antonyms)": ["N/A"], "समश्रुत भिन्नार्थक शब्द (Homonyms)": ["N/A"], "अनेकार्थक शब्द": ["N/A"], "वाक्यांश के लिए एक शब्द (One-word substitution)": ["N/A"], "समास (Compounds)": ["N/A"], "अलंकार": ["N/A"], "रस": ["N/A"], "छंद": ["N/A"], "वाक्य रचना (Sentence Structure)": ["N/A"], "वाक्य भेद (सरल, संयुक्त, मिश्र)": ["N/A"], "वाक्य शुद्धि (Error detection & correction)": ["N/A"], "अशुद्ध वाक्य शुद्ध करना": ["N/A"], "काल और वाच्य": ["N/A"], "लोकोक्तियाँ और मुहावरे": ["N/A"], "अपठित गद्यांश/काव्यांश": ["N/A"], "समझ आधारित प्रश्न (Comprehension)": ["N/A"], "पद-परिचय": ["N/A"], "संधि": ["N/A"], "शब्द शुद्धि और वर्तनी नियम": ["N/A"], "प्रत्यय और उपसर्ग": ["N/A"], "व्याकरण के अंश": ["संज्ञा (लिंग, वचन, कारक)", "सर्वनाम", "विशेषण (विभक्ति, वाचक विशेषण)", "क्रिया (सकर्मक, अकर्मक, सहायक क्रिया, भाववाचक)", "क्रियाविशेषण", "अव्यय", "समुच्चयबोधक, संबंधबोधक, विस्मयादिबोधक"]
            }
        },
        "Section B": {
            "Physics": {
                "EFFECT OF CURRENT": ["Potential; potential difference ohms law", "series combination of resistors, parallel relation combination of resistors", "Power dissipation due to current", "Inter relation between P,V,I and R", "Magnetic field & magnetic lines", "Magnetic field due to current carrying conductor", "Fleming left hand rule, Electromagnetic Induction", "Induced Potential Difference, Induced current", "Direct current, Alternating current", "Frequency of AC, Advantage of Electronic Motor & Electronic Generator"],
                "LIGHT": ["Convergence and Divergence of light", "Images. formed by a Concave Mirror", "related concepts, centre of curvature", "principles axis, optic centre, focus, focal length", "Refraction & laws of refraction", "Images formed by a convex lens", "functioning of vision and remedies", "Applications of spherical mirrors and lenses", "Appreciation of concept of refraction index", "Twinkling of stars", "Dispersion of light", "Scattering of light"],
                "The Human eye and the colourful world": ["Structure of eye", "Defects of eye and their correction"],
                "SOURCES OF ENERGY": ["Different forms of Energy", "Leading to different sources for human use: Fossil Fuels, solar energy", "Biogas", "Wind", "Water and Tidal Energy", "Nuclear Energy", "Renewable versus non-renewable sources"],
                "MOTION: FORCE AND NEWTON'S LAWS": ["Displacement, Velocity, uniform & non-uniform motion", "acceleration distance-time and velocity", "Time graphs for uniform and uniformly accelerated motion", "Equations of motion by graphical method", "Elementary idea of uniform circular motion", "Force and Motion", "Newton's laws of motion Inertia of a body", "Inertia and Mass, Momentum Force and acceleration", "Elementary idea of conservation of momentum, Action and Reaction forces"],
                "GRAVITATION: WORK, ENERGY AND POWER": ["Gravitation", "Universal Law of Gravitation", "Force of gravitation of the earth gravity, acceleration due to gravity", "mass and weight", "free fall", "Work done by a force energy, power", "Kinetic and Potential energy", "law of conservation of energy"],
                "FLOATATION": ["Thrust and Pressure", "Archimedes Principle", "Buoyancy", "Elementary idea of relative density"],
                "SOUND": ["Nature of Sound and its Propagation in various media, Speed of Sound", "Range of hearing in Humans", "Ultra Sound, Reflection of sound", "Echo and SONAR", "Structure of the Human Ear (Auditory aspect only)"]
            },
            "Chemistry": {
                "MATTER-NATURE AND BEHAVIOUR": ["Gases, liquids, solids, plasma and Bose-Enstein condenstate", "types of intermolecular forces", "Classification of matter into mixures and pure substances", "Henry's Law", "Concentration of solutions", "Colloids-phases of colloids, Tyndall effect, Brownian movement", "Suspension", "Properties of matter", "Measurement of properties of matter-S.I. system of units", "physical and chemical changes", "Laws of chemical combination Gay Lussac's law, Avogadro law", "atomic and molecular masses, average atomic. mass, mole concept and molar masses, percentage compostion"],
                "STRUCTURE OF ATOM": ["Dalton's atomic theory, Discharge tube experiments", "J.J. Thomson's model of atom, Rutherford's model, Bohr's model of atom", "electronic configuration, formation of ions", "Characterisation of elements as metals, metalloids, or nonmetals", "isotopes (their applications), isobars and isotones"],
                "PERIODIC CLASSIFICATION OF ELEMENTS": ["Mendeleev's periodic law", "Periodic properties of elements, trends in the periods and groups", "Improtance of the periodic table, position of hydrogen in the periodic table"],
                "CHEMICAL SUBSTANCES": ["Nature and behaviour Acid, Basis and Salts", "Classical definition of acids and bases, Bronsted-Lowry theory, Lewis conceipt of acid and bases", "relative.strengths of acids and bases, logarithmic or p scale-pH,pOH and pkw, ionic equilibria in a solution", "Action of indicators on acids and bases, sources of acid and bases", "SaltClassification of salts and their pH"],
                "CHEMICAL REACTIONS": ["Formulation of chemical equations, balancing chemical equations", "Types of chemical equations with examples"],
                "METALS AND NON-METALS": ["Characters of metals and non-metals including all properties and applications", "Occurrence of metals in nature: ores and minerals, enrichment of ores metallurgical operations", "Corrosion: rusting of iron - prevention of corrosion"],
                "CARBON COMPOUNDS": ["Position of carbon in the periodic table", "Concept of hybridization and shapes of molecules structural formula and molecular models", "types of reactions undergone by organic compounds, homologous series of compounds having different functional groups, isomerism, IUPAC nomenclature of organic compounds", "Hydrocarbons - their classification formation of coal and petroleum", "Industrial source, preparation and properties of alkanes", "Alcohols: Preparation and properties", "Qualitative analysis of alcohols, iodoform test, effect of alcohols on living beings", "Carboxylic acids: Preparation and properties", "Functional group analysís of carboxylic acid", "Soaps, detergents, biodegradable detergents", "Carbon fibres"],
                "MAN MADE MATERIAL": ["Ceramics, cement, porcelain, glass, carbon fibres, soaps and detergents, polymers, fibres 'and plastics"]
            },
            "Biology": {
                "Life Processes": ["What are life Processes", "Need for Nutrition", "Different modes of. Nutrition in animals", "What is Photosynthesis", "Various steps of holozoic nutrition", "Aerobic and anaerobic respiration", "Transportation in Human beings", "Transportation in Plants", "Transportation in animals", "Excretion in animals including Human beings", "Excretion in Plants"],
                "Control & Co-Ordination": ["Animals - nervous system", "Basic unit of Nervous System in animals", "Reflex action", "Human Brain", "Co-Ordination in plants", "Geotropism - Positive, Negative", "Hormones in animals", "Endocrine & Exocrine glands"],
                "Reproduction": ["Importance of variation", "Modes of Reproduction used by single organisms", "Sexual Reproduction in plants and animals", "Reproduction in Human beings", "What happens when egg is not fertilised", "Modes of avoiding pregnancy (family planning)"],
                "Heredity and Evolution": ["What is heredity?", "Medals Law of inheritance", "How is sex determined?", "Evolution & Classification", "Acquired and inherited traits", "Homologus and Analogous organs", "What are fossils?", "Human Evolution"],
                "Natural resources": ["The fundamental unit of Life", "What are living organisms made of?", "Structure organization of cell"],
                "Tissues": ["Define tissue", "Types of plants tissue and animals tissues"],
                "Diversity of living organisms": ["Basis of Classification", "Classification & Evolution", "Hierarchy of classification - - groups", "Plantae, Animalia", "Nomenclature"],
                "Why do we fall ill": ["Health & its failure", "Diseases and their causes", "Types of diseases- Infectious, Noninfectious", "Prevention of diseases Smmunisation"],
                "OUR ENVIRONMENT": ["Atmosphere, roll of atmosphere in climate control, wind, rain", "environmental pollution: Global warming and green house effect, acid rain, particulate pollutants, smog, formation of photochemical smog", "Formation of ozone and its break down ozone hole, causes of ozone hole formation, polar vortex, effects of depletion of ozone hole", "Water pollution-oxygen demand, chemical oxygen demand, internationalstandard of drinking water, processing of drinking water", "Soil pollution: water recycling, strategies to control environmental pollution, itscollection and proper methods of disposal", "Biogeochemical cycles: water cycle, nitrogen cycle, carbon cycle and oxygencycle"],
                "CONSERVATION OF NATURAL RESOURCES": ["Pollution of river water, Ganga action plan for improving quality of water", "Need for sustainable management of natural resources", "Development of non- conventional energy resources to prevent pollution and atmospheric conservation"],
                "Improvement in Food Resources": ["Improvement in crop yield", "Animal Husbandry", "Need for intercropping", "Cross Breeding"],
                "Bone and Cartilage": ["Structure and types of bones and cartilages, Ossification, bone growth and resorption"],
                "Animal Diversity": ["Kingdom Protista, Amphibia, Reptiles, Aves, Mammals", "Phylüm Porifera, Phylum Cnidaria, Phylüm Annelida, Phylum Arthròpoda, Phylum Mollusca"],
                "Comparative Anatomy and Developmental Biology of Vertebrates": ["Integumentary System", "Skeletal System", "Digestive System", "Respiratory System", "Circulatory System", "Urinogenital System", "Nervous system", "Sense Organ", "Early Embryonoic Development", "Late Embryonic Development", "Control of Development"],
                "Physiology and Biochemistry": ["Nerve and Muscle", "Digestion", "Respiration", "Excretion", "Cardiovascular System", "Reproduction and Endocrine Glands", "Carbohydrate Metabolism", "Lipid Metabolism", "Protein Metabolism", "Enzymes", "Extinction", "Macro-evolution"],
                "Applied Zoology": ["Introduction to Host-parasite Relationship", "Epidemiology of Diseases,Rickettsiaeand Spirochaetes", "Parasitic Protozoa", "Parasitic Helminthes", "Insects of Eco Importance,Insects of Medical Importance", "Animal Husbandry", "Poultry Farming", "Fish Technology"],
                "Aquatic Biology": ["Aquatic Biomes", "Freshwater Biology", "Marine Biology", "Management of Aquatic Resources"],
                "Immunology": ["Overview of the Immune System", "Cells and Organs of the Immune System", "Antigens", "Antibodies", "Working of the immune system", "Immune system in health and disease", "Vaccines"],
                "Reproductive Biology": ["Reproductive Endocrinology", "Functional anatomy of male reproduction", "Functional anatomy of female reproduction", "Reproductive Health"],
                "Insect, Vectors and Diseases": ["Introduction of Insects", "Concept of Vectors", "Insects as Vectors", "Dipteran as Disease Vectors", "Siphonaptera as disease vectors", "Hempitera as Disease Vectors"],
                "Sericulture": ["Introduction", "Biology of Silkworm", "Rearing of Silkworms", "Pests and Diseases"]
            }
        }
    };

    let questionsData = [];
    let reviewSession = {
        isActive: false,
        questions: [],
        currentIndex: 0
    };
    let currentlyEditingId = null; // Holds the ID of the question being edited
    // Added per request 3: Context for modal navigation
    let modalViewContext = { list: [], currentIndex: -1 };

    // Form Dropdown Elements
    const sectionSelect = document.getElementById('section');
    const subjectSelect = document.getElementById('subject');
    const topicSelect = document.getElementById('topic');
    const subtopicSelect = document.getElementById('subtopic');

    // Filter Dropdown Elements
    const filterPaperSelect = document.getElementById('filterPaper');
    // const filterSectionSelect = document.getElementById('filterSection'); // Removed per request 1
    const filterSubjectSelect = document.getElementById('filterSubject');
    const filterTopicSelect = document.getElementById('filterTopic');
    const filterSubtopicSelect = document.getElementById('filterSubtopic');

    /**
     * Helper function to render text or an image.
     * @param {string} text - The text content.
     * @param {string} imageBase64 - The Base64 encoded image string.
     * @returns {string} HTML string to render.
     */
    // MODIFIED per request 2: Improve text rendering to respect newlines
    function renderContent(text, imageBase64) {
        let content = '';
        if (text) {
            // Sanitize text by creating a text node
            const textNode = document.createTextNode(text);
            // Use a <pre> tag to preserve whitespace and newlines, but style it to wrap
            const pre = document.createElement('pre');
            pre.appendChild(textNode);
            pre.style.whiteSpace = 'pre-wrap'; // Ensure wrapping
            pre.style.fontFamily = 'inherit'; // Use body font
            pre.style.margin = '0'; // Reset <pre> default margin
            pre.style.padding = '0'; // Reset <pre> default padding
            pre.style.border = 'none'; // Reset <pre> default border
            pre.style.background = 'transparent'; // Reset <pre> default background
            content += pre.outerHTML;
        }
        if (imageBase64 && imageBase64.startsWith('data:image')) {
            content += `<img src="${imageBase64}" alt="Question content" style="max-width: 100%; height: auto; border-radius: 8px; margin-top: 5px;">`;
        }
        return content || '(No content)';
    }


    function populateDropdown(selectElement, items, prompt) {
        const currentValue = selectElement.value;
        selectElement.innerHTML = `<option value="">${prompt}</option>`;
        items.forEach(item => {
            const option = document.createElement('option');
            option.value = item;
            option.textContent = item;
            selectElement.appendChild(option);
        });
        selectElement.value = currentValue;
        selectElement.disabled = false;
    }

    // Form Dropdown Logic
    sectionSelect.addEventListener('change', function() {
        subjectSelect.innerHTML = '<option value="">Select Subject</option>';
        topicSelect.innerHTML = '<option value="">Select Topic</option>';
        subtopicSelect.innerHTML = '<option value="">Select Subtopic</option>';
        subjectSelect.disabled = true;
        topicSelect.disabled = true;
        subtopicSelect.disabled = true;
        if (this.value) {
            const subjects = Object.keys(syllabusStructure[this.value] || {});
            populateDropdown(subjectSelect, subjects, 'Select Subject');
        }
    });

    subjectSelect.addEventListener('change', function() {
        topicSelect.innerHTML = '<option value="">Select Topic</option>';
        subtopicSelect.innerHTML = '<option value="">Select Subtopic</option>';
        topicSelect.disabled = true;
        subtopicSelect.disabled = true;
        const section = sectionSelect.value;
        if (section && this.value) {
            const topics = Object.keys(syllabusStructure[section][this.value] || {});
            populateDropdown(topicSelect, topics, 'Select Topic');
        }
    });

    topicSelect.addEventListener('change', function() {
        subtopicSelect.innerHTML = '<option value="">Select Subtopic</option>';
        subtopicSelect.disabled = true;
        const section = sectionSelect.value;
        const subject = subjectSelect.value;
        if (section && subject && this.value) {
            const subtopics = syllabusStructure[section][subject][this.value] || [];
            populateDropdown(subtopicSelect, subtopics, 'Select Subtopic');
        }
    });
    
    // Filter Dropdown Logic
    
    // ADDED per request 1: Helper function to find section
    function findSectionForSubject(subjectName) {
        if (!subjectName) return null;
        if (syllabusStructure["Section A"][subjectName]) {
            return "Section A";
        }
        if (syllabusStructure["Section B"][subjectName]) {
            return "Section B";
        }
        return null; // Not found
    }
    
    // MODIFIED per request 1: Load all subjects, remove section dependency
    function updateFilterSubjectOptions() {
        filterSubjectSelect.innerHTML = '<option value="">All Subjects</option>';
        filterTopicSelect.innerHTML = '<option value="">All Topics</option>';
        filterSubtopicSelect.innerHTML = '<option value="">All Subtopics</option>';
        // filterSubjectSelect.disabled = true; // Removed
        filterTopicSelect.disabled = true;
        filterSubtopicSelect.disabled = true;
        
        // const section = filterSectionSelect.value; // Removed
        
        const subjectsA = Object.keys(syllabusStructure["Section A"] || {});
        const subjectsB = Object.keys(syllabusStructure["Section B"] || {});
        const allSubjects = [...new Set([...subjectsA, ...subjectsB])].sort();

        populateDropdown(filterSubjectSelect, allSubjects, 'All Subjects');
        filterSubjectSelect.disabled = false; // Enable it
        
        filterData();
    }
    
    // MODIFIED per request 1: Find section based on subject
    function updateFilterTopicOptions() {
        filterTopicSelect.innerHTML = '<option value="">All Topics</option>';
        filterSubtopicSelect.innerHTML = '<option value="">All Subtopics</option>';
        filterTopicSelect.disabled = true;
        filterSubtopicSelect.disabled = true;

        // const section = filterSectionSelect.value; // Removed
        const subject = filterSubjectSelect.value;
        const section = findSectionForSubject(subject); // Added
        
        if (section && subject) {
            const topics = Object.keys(syllabusStructure[section][subject] || {});
            populateDropdown(filterTopicSelect, topics, 'All Topics');
        }
        filterData();
    }

    // MODIFIED per request 1: Find section based on subject
    function updateFilterSubtopicOptions() {
        filterSubtopicSelect.innerHTML = '<option value="">All Subtopics</option>';
        filterSubtopicSelect.disabled = true;

        // const section = filterSectionSelect.value; // Removed
        const subject = filterSubjectSelect.value;
        const topic = filterTopicSelect.value;
        const section = findSectionForSubject(subject); // Added

        if (section && subject && topic) {
            const subtopics = syllabusStructure[section][subject][topic] || [];
            populateDropdown(filterSubtopicSelect, subtopics, 'All Subtopics');
        }
        filterData();
    }

    function addQuestion() {
        const formData = getFormData();
        if (!formData) return; // Validation failed

        const uniqueId = `${formData.paperNumber}-${formData.questionNumber}`;
        if (questionsData.some(q => `${q.paperNumber}-${q.questionNumber}` === uniqueId)) {
            if (!confirm(`Question ${formData.questionNumber} from Paper ${formData.paperNumber} already exists. Do you want to overwrite it?`)) {
                return;
            }
            // If user confirms overwrite, find and replace
            const indexToUpdate = questionsData.findIndex(q => `${q.paperNumber}-${q.questionNumber}` === uniqueId);
            questionsData[indexToUpdate] = formData;
        } else {
            // Otherwise, just add as new
            questionsData.push(formData);
        }

        questionsData.sort((a, b) => (a.paperNumber - b.paperNumber) || (a.questionNumber - b.questionNumber));
        saveData();
        renderTable();
        updateStats();
        updateAllFilterOptions();
        clearForm(); // This will clear text fields
        cancelEdit(); // This will reset buttons
    }

    /**
     * Reads all data from the form and returns a validated question object.
     * Returns null if validation fails.
     */
    function getFormData() {
         const formData = {
            paperNumber: document.getElementById('paperNumber').value,
            questionNumber: document.getElementById('questionNumber').value,
            section: sectionSelect.value,
            subject: subjectSelect.value,
            topic: topicSelect.value,
            subtopic: subtopicSelect.value,
            questionText: document.getElementById('questionText').value.trim(),
            questionImage: document.getElementById('questionImage').value.trim(),
            options: {
                a: document.getElementById('optionA').value.trim(),
                b: document.getElementById('optionB').value.trim(),
                c: document.getElementById('optionC').value.trim(),
                d: document.getElementById('optionD').value.trim(),
            },
            optionAImage: document.getElementById('optionAImage').value.trim(),
            optionBImage: document.getElementById('optionBImage').value.trim(),
            optionCImage: document.getElementById('optionCImage').value.trim(),
            optionDImage: document.getElementById('optionDImage').value.trim(),
            correctOption: document.getElementById('correctOption').value,
            correctAnswerText: document.getElementById('correctAnswerText').value.trim(),
            // Set defaults for review status, will be overwritten if updating
            reviewStatus: 'new',
            easeFactor: 2.5,
            interval: 0,
            nextReviewDate: new Date().toISOString()
        };

        const requiredFields = ['paperNumber', 'questionNumber', 'section', 'subject', 'topic', 'subtopic', 'correctOption'];
        for (let field of requiredFields) {
            // Allow subtopic 'N/A'
            if (field === 'subtopic' && formData[field] === 'N/A') continue;
            
            if (!formData[field]) {
                alert(`Please fill in the '${field}' field.`);
                return null;
            }
        }
        
        if (!formData.questionText && !formData.questionImage) {
            alert('Please provide either Question Text or a Question Image.');
            return null;
        }
        
        return formData;
    }

    /**
     * Clears all fields in the "Add Single Question" form.
     */
    function clearForm() {
        document.getElementById('formTitle').textContent = 'Add Single Question';
        document.getElementById('paperNumber').value = '';
        document.getElementById('questionNumber').value = '';
        
        sectionSelect.value = '';
        subjectSelect.innerHTML = '<option value="">Select Subject</option>';
        topicSelect.innerHTML = '<option value="">Select Topic</option>';
        subtopicSelect.innerHTML = '<option value="">Select Subtopic</option>';
        subjectSelect.disabled = true;
        topicSelect.disabled = true;
        subtopicSelect.disabled = true;
        
        document.getElementById('questionText').value = '';
        document.getElementById('questionImage').value = '';
        document.getElementById('optionA').value = '';
        document.getElementById('optionAImage').value = '';
        document.getElementById('optionB').value = '';
        document.getElementById('optionBImage').value = '';
        document.getElementById('optionC').value = '';
        document.getElementById('optionCImage').value = '';
        document.getElementById('optionD').value = '';
        document.getElementById('optionDImage').value = '';
        document.getElementById('correctOption').value = '';
        document.getElementById('correctAnswerText').value = '';
    }

    /**
     * Resets the form from "Edit" mode back to "Add" mode.
     */
    function cancelEdit() {
        currentlyEditingId = null;
        clearForm(); // clearForm will reset all the text fields
        
        // Reset button
        document.getElementById('addQuestionBtn').textContent = 'Add Question';
        document.getElementById('addQuestionBtn').onclick = addQuestion;
        document.getElementById('cancelEditBtn').style.display = 'none';
        document.getElementById('formTitle').textContent = 'Add Single Question';
    }

    /**
     * Loads a question's data into the form for editing.
     * @param {string} uniqueId - The ID of the question to edit (e.g., "1-101").
     */
    async function loadQuestionForEdit(uniqueId) {
        const question = questionsData.find(q => `${q.paperNumber}-${q.questionNumber}` === uniqueId);
        if (!question) return;

        // --- TEXT & NUMBER FIELDS ---
        document.getElementById('paperNumber').value = question.paperNumber;
        document.getElementById('questionNumber').value = question.questionNumber;
        document.getElementById('questionText').value = question.questionText || '';
        document.getElementById('questionImage').value = question.questionImage || '';
        
        document.getElementById('optionA').value = question.options.a || '';
        document.getElementById('optionAImage').value = question.optionAImage || '';
        document.getElementById('optionB').value = question.options.b || '';
        document.getElementById('optionBImage').value = question.optionBImage || '';
        document.getElementById('optionC').value = question.options.c || '';
        document.getElementById('optionCImage').value = question.optionCImage || '';
        document.getElementById('optionD').value = question.options.d || '';
        document.getElementById('optionDImage').value = question.optionDImage || '';
        
        document.getElementById('correctOption').value = question.correctOption || '';
        document.getElementById('correctAnswerText').value = question.correctAnswerText || '';

        // --- DYNAMIC DROPDOWNS ---
        // We need to set the value and trigger the change event to populate the next dropdown.
        
        // 1. Set Section
        sectionSelect.value = question.section;
        sectionSelect.dispatchEvent(new Event('change')); // Populates subjects
        
        // 2. Set Subject
        subjectSelect.value = question.subject;
        subjectSelect.dispatchEvent(new Event('change')); // Populates topics

        // 3. Set Topic
        topicSelect.value = question.topic;
        topicSelect.dispatchEvent(new Event('change')); // Populates subtopics

        // 4. Set Subtopic
        subtopicSelect.value = question.subtopic;

        // --- FORM STATE ---
        currentlyEditingId = uniqueId;
        document.getElementById('formTitle').textContent = `Editing Paper ${question.paperNumber} - Q# ${question.questionNumber}`;
        document.getElementById('addQuestionBtn').textContent = 'Update Question';
        document.getElementById('addQuestionBtn').onclick = updateQuestion;
        document.getElementById('cancelEditBtn').style.display = 'inline-block';

        // Scroll to the form
        document.querySelector('.form-container').scrollIntoView({ behavior: 'smooth', block: 'start' });
    }
    
    /**
     * Updates an existing question with data from the form.
     */
    function updateQuestion() {
        const formData = getFormData();
        if (!formData) return; // Validation failed

        // --- Check for ID conflict ---
        const newUniqueId = `${formData.paperNumber}-${formData.questionNumber}`;
        // Check if the new ID conflicts with an *existing* question that is *not* the one we're editing
        if (newUniqueId !== currentlyEditingId && questionsData.some(q => `${q.paperNumber}-${q.questionNumber}` === newUniqueId)) {
            alert(`Error: A question with Paper ${formData.paperNumber} and Q# ${formData.questionNumber} already exists. Cannot update to this ID.`);
            return;
        }

        // --- Find and update ---
        const indexToUpdate = questionsData.findIndex(q => `${q.paperNumber}-${q.questionNumber}` === currentlyEditingId);
        if (indexToUpdate !== -1) {
            // Preserve review stats from the original question
            const originalQuestion = questionsData[indexToUpdate];
            formData.reviewStatus = originalQuestion.reviewStatus || 'new';
            formData.easeFactor = originalQuestion.easeFactor || 2.5;
            formData.interval = originalQuestion.interval || 0;
            formData.nextReviewDate = originalQuestion.nextReviewDate || new Date().toISOString();
            
            // Replace the old question data with the new form data
            questionsData[indexToUpdate] = formData;
        } else {
            // This shouldn't happen if currentlyEditingId is set
            console.error("Error: Could not find question to update. Appending as new question instead.");
            questionsData.push(formData); // Fallback
        }

        questionsData.sort((a, b) => (a.paperNumber - b.paperNumber) || (a.questionNumber - b.questionNumber));
        saveData();
        renderTable();
        updateStats();
        updateAllFilterOptions();
        cancelEdit(); // Reset the form
    }


    function renderTable() {
        const tbody = document.getElementById('tableBody');
        tbody.innerHTML = '';
        const filtered = getFilteredData();

        document.getElementById('filteredQuestions').textContent = filtered.length;

        filtered.forEach((question) => {
            const row = document.createElement('tr');
            const uniqueId = `${question.paperNumber}-${question.questionNumber}`;
            // Added Edit button and moved Delete to its own column
            row.innerHTML = `
                <td><input type="checkbox" class="row-selector" data-id="${uniqueId}"></td>
                <td>${question.paperNumber}</td>
                <td>${question.questionNumber}</td>
                <td>${question.section}</td>
                <td>${question.subject}</td>
                <td>${question.topic}</td>
                <td>${question.subtopic}</td>
                <td>
                    <button class="btn action-btn" style="padding: 5px 10px;" onclick="showDetailsModal('${uniqueId}')">View</button>
                    <button class="btn btn-tertiary action-btn" style="padding: 5px 10px; margin-left: 5px;" onclick="loadQuestionForEdit('${uniqueId}')">Edit</button>
                </td>
                <td><button class="delete-btn" onclick="deleteQuestion('${uniqueId}')">Delete</button></td>
            `;
            tbody.appendChild(row);
        });
    }

    function updateStats() {
        const total = questionsData.length;
        const sectionA = questionsData.filter(q => q.section === 'Section A').length;
        const sectionB = questionsData.filter(q => q.section === 'Section B').length;

        document.getElementById('totalQuestions').textContent = total;
        document.getElementById('sectionAQuestions').textContent = sectionA;
        document.getElementById('sectionBQuestions').textContent = sectionB;
    }
    
    function updateAllFilterOptions() {
        const papers = [...new Set(questionsData.map(q => q.paperNumber))].sort((a,b) => a-b);
        populateDropdown(filterPaperSelect, papers, 'All Papers');
    }

    // MODIFIED per request 1 (remove section) and 4 (keyword search)
    function getFilteredData() {
        const paperFilter = filterPaperSelect.value;
        // const sectionFilter = filterSectionSelect.value; // Removed
        const subjectFilter = filterSubjectSelect.value;
        const topicFilter = filterTopicSelect.value;
        const subtopicFilter = filterSubtopicSelect.value;
        const searchKeyword = document.getElementById('searchKeyword').value.trim().toLowerCase(); // Changed

        return questionsData.filter(q => {
            // Trim data fields before comparison to be resilient to whitespace in imported data.
            // const qSection = q.section ? q.section.trim() : ''; // Removed
            const qSubject = q.subject ? q.subject.trim() : '';
            const qTopic = q.topic ? q.topic.trim() : '';
            const qSubtopic = q.subtopic ? q.subtopic.trim() : '';
            
            const paperMatch = !paperFilter || q.paperNumber == paperFilter;
            // const sectionMatch = !sectionFilter || qSection === sectionFilter; // Removed
            const subjectMatch = !subjectFilter || qSubject === subjectFilter;
            const topicMatch = !topicFilter || qTopic === topicFilter;
            const subtopicMatch = !subtopicFilter || qSubtopic === subtopicFilter;
            
            // Modified per request 4
            const keywordMatch = !searchKeyword || 
                                     (q.questionText && q.questionText.toLowerCase().includes(searchKeyword)) ||
                                     (q.questionNumber && q.questionNumber.toString().toLowerCase().includes(searchKeyword));

            return paperMatch && subjectMatch && topicMatch && subtopicMatch && keywordMatch; // Updated
        });
    }

    function filterData() {
        renderTable();
    }

    function deleteQuestion(uniqueId) {
        if (confirm(`Are you sure you want to delete this question entry?`)) {
            questionsData = questionsData.filter(q => `${q.paperNumber}-${q.questionNumber}` !== uniqueId);
            saveData();
            renderTable();
            updateStats();
            updateAllFilterOptions();
        }
    }
    
    function toggleSelectAll(checked) {
        document.querySelectorAll('.row-selector').forEach(checkbox => checkbox.checked = checked);
    }

    function deleteSelected() {
        const selectedIds = [...document.querySelectorAll('.row-selector:checked')].map(cb => cb.dataset.id);
        if (selectedIds.length === 0) {
            alert('Please select questions to delete.');
            return;
        }
        if (confirm(`Are you sure you want to delete ${selectedIds.length} selected questions?`)) {
            questionsData = questionsData.filter(q => !selectedIds.includes(`${q.paperNumber}-${q.questionNumber}`));
            saveData();
            renderTable();
            updateStats();
            updateAllFilterOptions();
        }
    }

    function deleteAll() {
        if (confirm('ARE YOU SURE you want to delete ALL questions? This action cannot be undone.')) {
            questionsData = [];
            saveData();
            renderTable();
            updateStats();
            updateAllFilterOptions();
        }
    }

    function copyMetadata() {
        const selectedIds = [...document.querySelectorAll('.row-selector:checked')].map(cb => cb.dataset.id);
        if (selectedIds.length === 0) {
            alert('Please select questions to copy metadata.');
            return;
        }

        const selectedQuestions = questionsData.filter(q => selectedIds.includes(`${q.paperNumber}-${q.questionNumber}`));
        
        // Create the NotebookLM prompt
        let metadataText = `Go through the selected source carefully. Based on the metadata (which comes from past year DSSSB exam paper analysis) and the question text (which contains actual previous exam questions), generate 10 most important questions that are most likely to appear in future exams.


🔹 Your Task:

Analyze the metadata + question text.

Identify the most exam-relevant questions.

Present them in the flashcard format shown below.


📘 Flashcard Creation Instructions

Input: Educational text (paragraph, notes, or previous question).
Processing: Read line by line.
Output: For each line, generate multiple-choice flashcards with:

One question (Q:)

Four answer choices (A, B, C, D)

The correct answer marked at the end with |


📑 Flashcard Format Example

Input Line:
We can tell something is alive if it moves on its own.

Flashcards Output:

Q: How do we tell the difference between what is alive and what is not alive?
A. By their size
B. By their color
C. By their movement
D. By their sound | C. By their movement


🛠 Rules You Must Follow

Generate 10 most important exam questions (not explanations).

Only one correct option per question.

Options should be slightly confusing but with one correct answer.

Stay within the subject, topic, and subtopic mentioned in the metadata.

Now, based on the following metadata and question text, generate the output:


`;

        // Add metadata for each selected question
        selectedQuestions.forEach((q, index) => {
            metadataText += `--- Metadata Example ${index + 1} ---\n`;
            metadataText += `Paper: ${q.paperNumber}\n`;
            metadataText += `Question #: ${q.questionNumber}\n`;
            metadataText += `Section: ${q.section}\n`;
            metadataText += `Subject: ${q.subject}\n`;
            metadataText += `Topic: ${q.topic}\n`;
            metadataText += `Subtopic: ${q.subtopic}\n`;
            metadataText += `Question: ${q.questionText || '(Image Question)'}\n`;
            metadataText += `Correct Option: ${q.correctOption}\n`;
            metadataText += `Explanation: ${q.correctAnswerText || 'N/A'}\n\n`;
        });

        // Copy to clipboard
        navigator.clipboard.writeText(metadataText)
            .then(() => {
                alert(`Metadata for ${selectedQuestions.length} questions copied to clipboard with NotebookLM prompt!`);
            })
            .catch(err => {
                console.error('Failed to copy: ', err);
                alert('Failed to copy metadata to clipboard. Please check console for details.');
            });
    }

    function saveData() {
        localStorage.setItem('dsssbExamAnalysisV5_Images', JSON.stringify(questionsData));
    }

    function loadData() {
        const data = localStorage.getItem('dsssbExamAnalysisV5_Images');
        if (data) {
            questionsData = JSON.parse(data);
        }
        renderTable();
        updateStats();
        updateAllFilterOptions();
        // MODIFIED per request 1: Initialize subject filter on load
        updateFilterSubjectOptions();
    }

    // Helper function to convert an array of objects to a CSV string
    function convertToCSV(data) {
        if (data.length === 0) return '';
        // Updated headers to include new fields
        const headers = [
            'Paper Number', 'Question Number', 'Section', 'Subject', 'Topic', 'Subtopic', 
            'Question Text', 'Option A', 'Option B', 'Option C', 'Option D', 
            'Correct Option', 'Correct Answer Text',
            'Question Image', 'Option A Image', 'Option B Image', 'Option C Image', 'Option D Image'
        ];
        
        const rows = data.map(q => {
            // Function to safely wrap a value in quotes for CSV
            const escapeCSV = (val) => {
                if (val === undefined || val === null) return '';
                const str = String(val);
                if (str.includes(',') || str.includes('"') || str.includes('\n')) {
                    return `"${str.replace(/"/g, '""')}"`;
                }
                return str;
            };
            
            return [
                escapeCSV(q.paperNumber),
                escapeCSV(q.questionNumber),
                escapeCSV(q.section),
                escapeCSV(q.subject),
                escapeCSV(q.topic),
                escapeCSV(q.subtopic),
                escapeCSV(q.questionText),
                escapeCSV(q.options ? q.options.a : ''), // Handle old data structure
                escapeCSV(q.options ? q.options.b : ''),
                escapeCSV(q.options ? q.options.c : ''),
                escapeCSV(q.options ? q.options.d : ''),
                escapeCSV(q.correctOption),
                escapeCSV(q.correctAnswerText), // Replaced old correctAnswer
                escapeCSV(q.questionImage),
                escapeCSV(q.optionAImage),
                escapeCSV(q.optionBImage),
                escapeCSV(q.optionCImage),
                escapeCSV(q.optionDImage)
            ].join(',');
        });

        return [headers.join(','), ...rows].join('\n');
    }

    // Helper function to trigger the download of a CSV file
    function downloadCSV(csvContent, filename) {
        // Add BOM for proper Excel UTF-8 support
        const bom = new Uint8Array([0xEF, 0xBB, 0xBF]);
        const blob = new Blob([bom, csvContent], { type: 'text/csv;charset=utf-8;' });
        const link = document.createElement("a");
        const url = URL.createObjectURL(blob);
        link.setAttribute("href", url);
        link.setAttribute("download", filename);
        link.style.visibility = 'hidden';
        document.body.appendChild(link);
        link.click();
        document.body.removeChild(link);
    }

    // Exports all questions to CSV
    function exportData() {
        if (questionsData.length === 0) {
            alert('No data to export!');
            return;
        }
        try {
            const csvContent = convertToCSV(questionsData);
            downloadCSV(csvContent, 'dsssb_exam_analysis_full_with_images.csv');
        } catch (error) {
            console.error('Error exporting all data:', error);
            alert('An error occurred while exporting all questions. Base64 strings can be very large and cause issues. Please check the console for details.');
        }
    }

    // Exports only the currently filtered questions to CSV
    function exportFilteredData() {
        const filteredData = getFilteredData();
        if (filteredData.length === 0) {
            alert('No filtered data to export! Try adjusting your filters.');
            return;
        }
        try {
            const csvContent = convertToCSV(filteredData);
            downloadCSV(csvContent, 'dsssb_exam_analysis_filtered_with_images.csv');
        } catch (error) {
            console.error('Error exporting filtered data:', error);
            alert('An error occurred while exporting filtered questions. Base64 strings can be very large and cause issues. Please check the console for details.');
        }
    }
    
    // Updated import function to handle new CSV format
    function importData(event) {
        const file = event.target.files[0];
        if (!file) return;

        const reader = new FileReader();
        reader.onload = function(e) {
            try {
                const text = e.target.result;
                const rows = text.split('\n');
                
                // Parse header row to find column indices
                const headers = rows[0].split(/,(?=(?:(?:[^"]*"){2})*[^"]*$)/).map(h => h.replace(/^"|"$/g, '').replace(/""/g, '"').trim());
                
                const colMap = {};
                headers.forEach((h, i) => colMap[h] = i);

                // Check for essential headers
                if (!('Paper Number' in colMap) || !('Question Number' in colMap) || !('Section' in colMap) || !('Subject' in colMap) || !('Topic' in colMap) || !('Correct Option' in colMap)) {
                    alert('Invalid CSV format. Missing one of the required columns: Paper Number, Question Number, Section, Subject, Topic, Correct Option.');
                    return;
                }

                const importedQuestions = [];
                for (let i = 1; i < rows.length; i++) {
                    const rowStr = rows[i].trim();
                    if (rowStr === '') continue;
                    
                    const columns = rowStr.split(/,(?=(?:(?:[^"]*"){2})*[^"]*$)/).map(field => field.replace(/^"|"$/g, '').replace(/""/g, '"'));
                    
                    if (columns.length < headers.length) continue; // Skip malformed rows

                    const q = {
                        paperNumber: columns[colMap['Paper Number']],
                        questionNumber: columns[colMap['Question Number']],
                        section: columns[colMap['Section']],
                        subject: columns[colMap['Subject']],
                        topic: columns[colMap['Topic']],
                        subtopic: columns[colMap['Subtopic']] || 'N/A',
                        questionText: columns[colMap['Question Text']] || '',
                        options: {
                            a: columns[colMap['Option A']] || '',
                            b: columns[colMap['Option B']] || '',
                            c: columns[colMap['Option C']] || '',
                            d: columns[colMap['Option D']] || ''
                        },
                        correctOption: columns[colMap['Correct Option']],
                        correctAnswerText: columns[colMap['Correct Answer Text']] || '',
                        questionImage: columns[colMap['Question Image']] || '',
                        optionAImage: columns[colMap['Option A Image']] || '',
                        optionBImage: columns[colMap['Option B Image']] || '',
                        optionCImage: columns[colMap['Option C Image']] || '',
                        optionDImage: columns[colMap['Option D Image']] || '',
                        reviewStatus: 'new', 
                        easeFactor: 2.5, 
                        interval: 0, 
                        nextReviewDate: new Date().toISOString()
                    };
                    importedQuestions.push(q);
                }


                if (confirm(`Found ${importedQuestions.length} questions in the CSV. Do you want to overwrite existing data?`)) {
                    questionsData = importedQuestions;
                    questionsData.sort((a, b) => (a.paperNumber - b.paperNumber) || (a.questionNumber - b.questionNumber));
                    saveData();
                    renderTable();
                    updateStats();
                    updateAllFilterOptions();
                    alert('Data imported successfully!');
                }
            } catch (error) {
                alert('Failed to import CSV. Please check the file format and console for errors.');
                console.error(error);
            }
        };
        reader.readAsText(file);
        event.target.value = '';
    }

    function batchImport() {
        const batchDataEl = document.getElementById('batchData');
        const text = batchDataEl.value.trim();
        if (!text) {
            alert('Please paste data from the Gem or Converter into the text area.');
            return;
        }

        try {
            const batch = JSON.parse(text);
            if (!Array.isArray(batch)) {
                throw new Error('Pasted data is not a JSON array.');
            }

            let addedCount = 0;
            let overwrittenCount = 0;
            
            batch.forEach(q => {
                let importedCorrectOption = q.correctOption;
                let importedCorrectAnswerText = q.correctAnswerText;

                // Handle old JSON format (which has 'correctAnswer' with text)
                // Check if 'correctAnswer' exists AND 'correctOption' does NOT
                if (q.correctAnswer && !q.correctOption && q.options) {
                    importedCorrectAnswerText = q.correctAnswer; // Use the text as the explanation
                    
                    // Find the matching option key
                    for (const key in q.options) {
                        if (q.options[key] === q.correctAnswer) {
                            importedCorrectOption = key.toUpperCase(); // 'a' -> 'A'
                            break; // Stop searching once found
                        }
                    }
                }
                // Handle new JSON format (which might have correctOption but not text)
                else if (q.correctOption && !q.correctAnswerText && q.options) {
                    const optKey = q.correctOption.toLowerCase(); // 'A' -> 'a'
                    if (q.options[optKey]) {
                        importedCorrectAnswerText = q.options[optKey]; // Set text from the option
                    }
                }

                // Ensure the new fields exist
                const newQuestionData = {
                    ...q,
                    questionImage: q.questionImage || '',
                    optionAImage: q.optionAImage || '',
                    optionBImage: q.optionBImage || '',
                    optionCImage: q.optionCImage || '',
                    optionDImage: q.optionDImage || '',
                    correctOption: importedCorrectOption || '', // Use the processed value
                    correctAnswerText: importedCorrectAnswerText || '', // Use the processed value
                    options: q.options || { a: '', b: '', c: '', d: '' },
                    reviewStatus: q.reviewStatus || 'new',
                    easeFactor: q.easeFactor || 2.5,
                    interval: q.interval || 0,
                    nextReviewDate: q.nextReviewDate || new Date().toISOString()
                };

                const uniqueId = `${newQuestionData.paperNumber}-${newQuestionData.questionNumber}`;
                const existingIndex = questionsData.findIndex(item => `${item.paperNumber}-${item.questionNumber}` === uniqueId);

                if (existingIndex !== -1) {
                    questionsData[existingIndex] = { ...questionsData[existingIndex], ...newQuestionData };
                    overwrittenCount++;
                } else {
                    questionsData.push(newQuestionData);
                    addedCount++;
                }
            });
            
            questionsData.sort((a, b) => (a.paperNumber - b.paperNumber) || (a.questionNumber - b.questionNumber));
            saveData();
            renderTable();
            updateStats();
            updateAllFilterOptions();
            batchDataEl.value = '';
            alert(`Batch import complete!\nAdded: ${addedCount} new questions.\nOverwritten: ${overwrittenCount} existing questions.`);

        } catch (error) {
            alert('Failed to parse batch data. Please ensure it is a valid JSON array copied from the Gem or Converter.');
            console.error(error);
        }
    }
    
    // Review Panel Logic
    function startReview() {
        reviewSession.questions = getFilteredData();
        if (reviewSession.questions.length === 0) {
            alert('No questions match the current filters. Please adjust filters to start a review.');
            return;
        }
        reviewSession.isActive = true;
        reviewSession.currentIndex = 0;
        document.getElementById('reviewPanel').classList.add('visible');
        loadNextCard();
    }

    function closeReview() {
        reviewSession.isActive = false;
        document.getElementById('reviewPanel').classList.remove('visible');
    }

    // MODIFIED per request 3: Add metadata, update counter, reset nav
    function loadNextCard() {
        if (reviewSession.currentIndex >= reviewSession.questions.length) {
            alert('Review session complete!');
            closeReview();
            return;
        }

        const progress = ((reviewSession.currentIndex + 1) / reviewSession.questions.length) * 100;
        document.getElementById('reviewProgressBar').style.width = `${progress}%`;

        // Update nav controls state
        document.getElementById('reviewCounter').textContent = `${reviewSession.currentIndex + 1} / ${reviewSession.questions.length}`;
        document.getElementById('reviewPrevBtn').disabled = (reviewSession.currentIndex === 0);
        document.getElementById('reviewNextBtn').disabled = false; // It's never disabled unless at end

        const card = reviewSession.questions[reviewSession.currentIndex];
        const flashcardContent = document.getElementById('flashcardContent');
        
        // --- Add metadata (request 3) ---
        let metadataDiv = flashcardContent.querySelector('.flashcard-metadata');
        if (!metadataDiv) {
            metadataDiv = document.createElement('div');
            metadataDiv.className = 'flashcard-metadata';
            metadataDiv.style.background = "#eef5f9";
            metadataDiv.style.borderRadius = "8px";
            metadataDiv.style.padding = "10px";
            metadataDiv.style.marginBottom = "15px";
            metadataDiv.style.fontSize = "0.85rem";
            flashcardContent.insertBefore(metadataDiv, flashcardContent.firstChild);
        }
        metadataDiv.innerHTML = `
            <p style="margin: 0;"><strong>Subject:</strong> ${card.subject}</p>
            <p style="margin: 0;"><strong>Topic:</strong> ${card.topic}</p>
            <p style="margin: 0;"><strong>Subtopic:</strong> ${card.subtopic}</p>
        `;
        
        const flashcardQuestionText = flashcardContent.querySelector('.flashcard-question-text');
        const flashcardOptions = flashcardContent.querySelector('.flashcard-options');
        
        flashcardQuestionText.innerHTML = renderContent(card.questionText, card.questionImage);
        
        const optionsList = flashcardOptions.getElementsByTagName('li');
        optionsList[0].innerHTML = `A) ${renderContent(card.options.a, card.optionAImage)}`;
        optionsList[1].innerHTML = `B) ${renderContent(card.options.b, card.optionBImage)}`;
        optionsList[2].innerHTML = `C) ${renderContent(card.options.c, card.optionCImage)}`;
        optionsList[3].innerHTML = `D) ${renderContent(card.options.d, card.optionDImage)}`;

        // Prepare answer content
        let answerContent = '';
        const correctOpt = card.correctOption; // 'A', 'B', 'C', or 'D'
        if (correctOpt) {
            answerContent = `<p><strong>Correct Option: ${correctOpt}</strong></p>`;
            let text, image;
            switch(correctOpt) {
                case 'A': text = card.options.a; image = card.optionAImage; break;
                case 'B': text = card.options.b; image = card.optionBImage; break;
                case 'C': text = card.options.c; image = card.optionCImage; break;
                case 'D': text = card.options.d; image = card.optionDImage; break;
            }
            if(text || image) { // Only add content if there is text or an image
                answerContent += renderContent(text, image);
            }
        }
        if (card.correctAnswerText) {
            answerContent += `<hr style="margin: 10px 0;"><p><strong>Explanation:</strong></p>${renderContent(card.correctAnswerText, null)}`;
        }
        
        document.getElementById('flashcardAnswer').innerHTML = answerContent || '<p><strong>Correct Option: ' + correctOpt + '</strong></p><p>(No answer details provided.)</p>';
        
        // Reset button states
        document.getElementById('flashcardAnswer').style.display = 'none';
        document.getElementById('showAnswerBtn').style.display = 'block';
        document.getElementById('ratingControls').style.display = 'none';
        document.getElementById('navControls').style.display = 'none';
    }

    // MODIFIED per request 3: Show Nav controls instead of Rating
    function showAnswer() {
        document.getElementById('flashcardAnswer').style.display = 'block';
        document.getElementById('showAnswerBtn').style.display = 'none';
        document.getElementById('ratingControls').style.display = 'none'; // Keep hidden
        document.getElementById('navControls').style.display = 'flex'; // Show nav
    }

    // ADDED per request 3: Navigation for review panel
    function navigateReview(direction) {
        const newIndex = reviewSession.currentIndex + direction;
        
        if (newIndex < 0) {
            return; // Can't go before start
        }
        
        if (newIndex >= reviewSession.questions.length) {
            // Stay on last card if trying to go next
            if(direction > 0) return;
        }

        // Check if we are at the end
        if (newIndex === reviewSession.questions.length) {
             alert('Review session complete!');
             closeReview();
             return;
        }
        
        reviewSession.currentIndex = newIndex;
        loadNextCard();
    }


    function rateCard(rating) {
        // This function is no longer used by default but kept for posterity
        console.log(`Card rated as: ${rating}`);
        
        reviewSession.currentIndex++;
        loadNextCard();
    }

    // Modal Logic
    const modal = document.getElementById('detailsModal');

    // ADDED per request 3: New function to render modal content
    function renderModalContent(uniqueId, index) {
        const question = questionsData.find(q => `${q.paperNumber}-${q.questionNumber}` === uniqueId);
        if (!question) return;

        // Update context
        modalViewContext.currentIndex = index;

        document.getElementById('modalTitle').textContent = `Details for Paper ${question.paperNumber} - Q#${question.questionNumber}`;
        const modalBody = document.getElementById('modalBody');
        
        // Added metadata
        let bodyHtml = `
            <div style="background: #f8f9fa; border-radius: 8px; padding: 10px 15px; margin-bottom: 15px; font-size: 0.9rem;">
                <p style="margin: 2px 0;"><strong>Subject:</strong> ${question.subject}</p>
                <p style="margin: 2px 0;"><strong>Topic:</strong> ${question.topic}</p>
                <p style="margin: 2px 0;"><strong>Subtopic:</strong> ${question.subtopic}</p>
            </div>
        `;
        
        bodyHtml += `<p><strong>Question:</strong></p>${renderContent(question.questionText, question.questionImage)}`;
        bodyHtml += `<hr style="margin: 15px 0;">`;
        bodyHtml += `<p><strong>Options:</strong></p>`;
        
        const options = [
            { id: 'A', text: question.options.a, image: question.optionAImage },
            { id: 'B', text: question.options.b, image: question.optionBImage },
            { id: 'C', text: question.options.c, image: question.optionCImage },
            { id: 'D', text: question.options.d, image: question.optionDImage }
        ];

        options.forEach(opt => {
            const isCorrect = question.correctOption === opt.id;
            bodyHtml += `
                <div class="modal-option ${isCorrect ? 'correct' : ''}">
                    <strong class="${isCorrect ? 'correct-label' : ''}">Option ${opt.id}:</strong>
                    ${renderContent(opt.text, opt.image)}
                </div>
            `;
        });

        if (question.correctAnswerText) {
            bodyHtml += `<hr style="margin: 15px 0;">`;
            bodyHtml += `<p><strong>Explanation:</strong></p>${renderContent(question.correctAnswerText, null)}`;
        }
        
        // Added next/prev buttons
        bodyHtml += `
            <div class="modal-footer" style="display: flex; justify-content: space-between; align-items: center; margin-top: 20px; padding-top: 15px; border-top: 1px solid #e0e6ed;">
                <button class="btn btn-tertiary" id="modalPrevBtn" onclick="navigateModal(-1)" ${index === 0 ? 'disabled' : ''}>&larr; Previous</button>
                <span style="font-size: 0.9rem; color: #555; white-space: nowrap;">${index + 1} / ${modalViewContext.list.length}</span>
                <button class="btn" id="modalNextBtn" onclick="navigateModal(1)" ${index === modalViewContext.list.length - 1 ? 'disabled' : ''}>Next &rarr;</button>
            </div>
        `;

        modalBody.innerHTML = bodyHtml;
    }

    // ADDED per request 3: Navigation function for modal
    function navigateModal(direction) {
        const newIndex = modalViewContext.currentIndex + direction;
        if (newIndex >= 0 && newIndex < modalViewContext.list.length) {
            const newUniqueId = modalViewContext.list[newIndex];
            renderModalContent(newUniqueId, newIndex);
        }
    }
    
    // MODIFIED per request 3: Refactored to use new render function
    function showDetailsModal(uniqueId) {
        // Populate context
        modalViewContext.list = getFilteredData().map(q => `${q.paperNumber}-${q.questionNumber}`);
        const index = modalViewContext.list.indexOf(uniqueId);
        
        if (index === -1) {
            console.error("Could not find question in filtered list.");
            // Fallback: Show the question anyway but without context
            modalViewContext.list = questionsData.map(q => `${q.paperNumber}-${q.questionNumber}`);
            const fallbackIndex = modalViewContext.list.indexOf(uniqueId);
            if (fallbackIndex === -1) {
                 alert("Error: Could not find question data.");
                 return;
            }
             renderModalContent(uniqueId, fallbackIndex);
        } else {
             renderModalContent(uniqueId, index); // Call the new render function
        }
        
        modal.style.display = 'flex';
    }


    function closeDetailsModal() {
        modal.style.display = 'none';
        modalViewContext = { list: [], currentIndex: -1 }; // Clear context
    }

    window.onclick = function(event) {
        if (event.target == modal) {
            closeDetailsModal();
        }
    }
    
    document.getElementById('csvFileInput').addEventListener('change', importData);
    document.addEventListener('DOMContentLoaded', loadData);

    </script>
</body>
</html>
